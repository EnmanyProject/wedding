import { Database } from '../utils/database';
import { config } from '../utils/config';
import { UserPointBalance, UserPointLedger, Affinity } from '../types/database';
import { v4 as uuidv4 } from 'uuid';

export interface PointTransaction {
  delta: number;
  reason: 'TRAIT_ADD' | 'QUIZ_ENTER' | 'QUIZ_WRONG' | 'DAILY_BONUS' | 'PURCHASE';
  refId?: string;
}

export class PointsService {
  private db: Database;
  private rankingCache: Map<string, { data: any; timestamp: number }> = new Map();
  private readonly RANKING_CACHE_TTL = 30000; // 30Ï¥à ÏÑúÎ≤Ñ Ï∫êÏãú

  constructor() {
    this.db = Database.getInstance();
  }

  /**
   * Get user's current point balance and recent transactions
   */
  async getUserPoints(userId: string): Promise<{
    balance: number;
    recentTransactions: Array<{
      id: string;
      delta: number;
      reason: string;
      created_at: Date;
    }>;
  }> {
    // Get balance
    const [balance] = await this.db.query<UserPointBalance>(
      'SELECT balance FROM user_point_balances WHERE user_id = $1',
      [userId]
    );

    // Get recent transactions (last 10)
    const transactions = await this.db.query<UserPointLedger>(
      `SELECT id, delta, reason, created_at
       FROM user_point_ledger
       WHERE user_id = $1
       ORDER BY created_at DESC
       LIMIT 10`,
      [userId]
    );

    return {
      balance: balance?.balance || 0,
      recentTransactions: transactions.map(t => ({
        id: t.id,
        delta: t.delta,
        reason: t.reason,
        created_at: t.created_at
      }))
    };
  }

  /**
   * Award points to user
   */
  async earnPoints(userId: string, transaction: PointTransaction): Promise<{
    delta: number;
    newBalance: number;
    transactionId: string;
  }> {
    return await this.db.transaction(async (client) => {
      // Ensure user has point balance record
      await this.ensurePointBalance(client, userId);

      // Update balance
      const [updatedBalance] = await client.query<UserPointBalance>(
        'UPDATE user_point_balances SET balance = balance + $1, updated_at = NOW() WHERE user_id = $2 RETURNING balance',
        [transaction.delta, userId]
      );

      // Record transaction
      const transactionId = uuidv4();
      await client.query(
        `INSERT INTO user_point_ledger (id, user_id, delta, reason, ref_id, created_at)
         VALUES ($1, $2, $3, $4, $5, NOW())`,
        [transactionId, userId, transaction.delta, transaction.reason, transaction.refId]
      );

      return {
        delta: transaction.delta,
        newBalance: updatedBalance.balance,
        transactionId
      };
    });
  }

  /**
   * Spend points (negative delta)
   */
  async spendPoints(userId: string, amount: number, reason: string, refId?: string): Promise<{
    success: boolean;
    newBalance?: number;
    transactionId?: string;
  }> {
    return await this.db.transaction(async (client) => {
      // Check current balance
      const [balance] = await client.query<UserPointBalance>(
        'SELECT balance FROM user_point_balances WHERE user_id = $1',
        [userId]
      );

      if (!balance || balance.balance < amount) {
        return { success: false };
      }

      // Deduct points
      const [updatedBalance] = await client.query<UserPointBalance>(
        'UPDATE user_point_balances SET balance = balance - $1, updated_at = NOW() WHERE user_id = $2 RETURNING balance',
        [amount, userId]
      );

      // Record transaction
      const transactionId = uuidv4();
      await client.query(
        `INSERT INTO user_point_ledger (id, user_id, delta, reason, ref_id, created_at)
         VALUES ($1, $2, $3, $4, $5, NOW())`,
        [transactionId, userId, -amount, reason, refId]
      );

      return {
        success: true,
        newBalance: updatedBalance.balance,
        transactionId
      };
    });
  }

  /**
   * Initialize user point balance
   */
  async initializeUserPoints(userId: string, initialBalance: number = 10000): Promise<void> {
    await this.db.query(
      `INSERT INTO user_point_balances (user_id, balance, updated_at)
       VALUES ($1, $2, NOW())
       ON CONFLICT (user_id) DO NOTHING`,
      [userId, initialBalance]
    );
  }

  /**
   * Ensure user has point balance record
   */
  private async ensurePointBalance(client: any, userId: string): Promise<void> {
    const [existing] = await client.query(
      'SELECT user_id FROM user_point_balances WHERE user_id = $1',
      [userId]
    );

    if (!existing) {
      await client.query(
        `INSERT INTO user_point_balances (user_id, balance, updated_at)
         VALUES ($1, $2, NOW())`,
        [userId, 10000] // Default balance
      );
    }
  }
}

export class AffinityService {
  private db: Database;
  private rankingCache: Map<string, { data: any; timestamp: number }> = new Map();
  private readonly RANKING_CACHE_TTL = 30000; // 30Ï¥à ÏÑúÎ≤Ñ Ï∫êÏãú

  constructor() {
    this.db = Database.getInstance();
  }

  /**
   * Get affinity between two users
   */
  async getAffinity(viewerId: string, targetId: string): Promise<{
    targetId: string;
    score: number;
    stagesUnlocked: string[];
    photosUnlocked: number;
    lastQuizAt?: Date;
    canQuiz: boolean;
  }> {
    const [affinity] = await this.db.query<Affinity>(
      'SELECT * FROM affinity WHERE viewer_id = $1 AND target_id = $2',
      [viewerId, targetId]
    );

    const score = affinity?.score || 0;
    const stagesUnlocked = affinity?.stages_unlocked || [];

    // Count unlocked photos
    const [photoCount] = await this.db.query(
      `SELECT COUNT(*) as count
       FROM photo_mask_states pms
       JOIN user_photos up ON pms.photo_id = up.id
       WHERE pms.user_id = $1 AND up.user_id = $2 AND pms.visible_stage != 'LOCKED'`,
      [viewerId, targetId]
    );

    // Check if can quiz (limit to prevent spam)
    const canQuiz = await this.canUserQuiz(viewerId, targetId);

    return {
      targetId,
      score,
      stagesUnlocked,
      photosUnlocked: photoCount?.count || 0,
      lastQuizAt: affinity?.last_quiz_at,
      canQuiz
    };
  }

  /**
   * Check if user can start a quiz with target
   */
  async canUserQuiz(viewerId: string, targetId: string): Promise<boolean> {
    // Check point balance
    const [balance] = await this.db.query(
      'SELECT balance FROM user_point_balances WHERE user_id = $1',
      [viewerId]
    );

    if (!balance || balance.balance < config.QUIZ_ENTER_COST) {
      return false;
    }

    // Check rate limiting (max 3 quizzes per target per hour)
    const [recentQuizzes] = await this.db.query(
      `SELECT COUNT(*) as count
       FROM quiz_sessions
       WHERE asker_id = $1 AND target_id = $2 AND started_at > NOW() - INTERVAL '1 hour'`,
      [viewerId, targetId]
    );

    return (recentQuizzes?.count || 0) < 3;
  }

  /**
   * Get user's ranking relative to a target
   */
  async getUserRanking(userId: string): Promise<{
    rankings: Array<{
      targetId: string;
      targetName: string;
      rankPosition: number;
      affinityScore: number;
      photosUnlocked: number;
      canMeet: boolean;
    }>;
    userPosition?: {
      rank: number;
      percentile: number;
    };
  }> {
    console.log('üèÜ [AffinityService] getUserRanking ÏãúÏûë:', userId);

    // üõ°Ô∏è Ï∫êÏãú ÏãúÏä§ÌÖú ÏïàÏ†ÑÏÑ± Í≤ÄÏ¶ù
    try {
      // ÏÑúÎ≤Ñ Î©îÎ™®Î¶¨ Ï∫êÏãú ÌôïÏù∏ (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
      const cacheKey = `ranking_${userId}`;

      // Ï∫êÏãúÍ∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Ï¥àÍ∏∞ÌôîÎêòÏóàÎäîÏßÄ ÌôïÏù∏
      if (this.rankingCache && this.rankingCache instanceof Map) {
        const cached = this.rankingCache.get(cacheKey);

        if (cached && Date.now() - cached.timestamp < this.RANKING_CACHE_TTL) {
          console.log('‚ö° [AffinityService] ÏÑúÎ≤Ñ Ï∫êÏãú ÌûàÌä∏ - Ï¶âÏãú Î∞òÌôò');
          return cached.data;
        }
      } else {
        // Ï∫êÏãúÍ∞Ä ÏÜêÏÉÅÎêú Í≤ΩÏö∞ Ïû¨Ï¥àÍ∏∞Ìôî
        console.warn('‚ö†Ô∏è [AffinityService] Ï∫êÏãú ÏãúÏä§ÌÖú ÏÜêÏÉÅ Í∞êÏßÄ - Ïû¨Ï¥àÍ∏∞Ìôî');
        this.rankingCache = new Map();
      }
    } catch (cacheError) {
      // Ï∫êÏãú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌï¥ÎèÑ ÏÑúÎπÑÏä§Îäî Í≥ÑÏÜç ÏûëÎèô
      console.error('üö® [AffinityService] Ï∫êÏãú ÏùΩÍ∏∞ Ïò§Î•ò:', cacheError);
      console.log('üîÑ [AffinityService] Ï∫êÏãú Ïö∞ÌöåÌïòÏó¨ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÏßÅÏ†ë Ï°∞Ìöå');

      // Ï∫êÏãú ÏãúÏä§ÌÖúÏùÑ Ïû¨Ï¥àÍ∏∞Ìôî
      try {
        this.rankingCache = new Map();
      } catch (reinitError) {
        console.error('üí• [AffinityService] Ï∫êÏãú Ïû¨Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', reinitError);
        // Ï∫êÏãú ÏóÜÏù¥ÎèÑ ÏûëÎèô Í∞ÄÎä•ÌïòÎèÑÎ°ù nullÎ°ú ÏÑ§Ï†ï
        this.rankingCache = null;
      }
    }

    console.log('üîç [AffinityService] Ï∫êÏãú ÎØ∏Ïä§ - ÏÉàÎ°úÏö¥ ÏøºÎ¶¨ Ïã§Ìñâ');

    let rankings = [];

    try {
      // üõ°Ô∏è Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏûëÏóÖÏùÑ ÏïàÏ†ÑÌïòÍ≤å ÏàòÌñâ

      // Check if ranking cache exists for user
      const [cacheCount] = await this.db.query(
        'SELECT COUNT(*) as count FROM user_ranking_cache WHERE user_id = $1',
        [userId]
      );

      console.log('üìä [AffinityService] Îû≠ÌÇπ Ï∫êÏãú ÏÉÅÌÉú:', {
        userId,
        cacheCount: cacheCount?.count || 0
      });

      // If no cache exists, update it first
      if (!cacheCount || cacheCount.count === 0) {
        console.log('‚ö†Ô∏è [AffinityService] Îû≠ÌÇπ Ï∫êÏãúÍ∞Ä ÏóÜÏùå, ÏÉùÏÑ± Ï§ë...');

        try {
          await this.updateRankingCache(userId);
          console.log('‚úÖ [AffinityService] Îû≠ÌÇπ Ï∫êÏãú ÏÉùÏÑ± ÏôÑÎ£å');
        } catch (updateError) {
          console.error('üö® [AffinityService] Îû≠ÌÇπ Ï∫êÏãú ÏÉùÏÑ± Ïã§Ìå®:', updateError);
          // Ï∫êÏãú ÏÉùÏÑ± Ïã§Ìå®Ïãú Îπà Í≤∞Í≥ºÎ°ú ÎåÄÏ≤¥ÌïòÏó¨ ÏãúÏä§ÌÖú ÏïàÏ†ïÏÑ± Ïú†ÏßÄ
          console.log('üîÑ [AffinityService] Îπà Îû≠ÌÇπÏúºÎ°ú ÎåÄÏ≤¥ÌïòÏó¨ ÏïàÏ†ïÏÑ± Ïú†ÏßÄ');

          return {
            rankings: [],
            userPosition: undefined
          };
        }
      }

      // Get rankings for user
      console.log('üîç [AffinityService] Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë...');
      rankings = await this.db.query(
        `SELECT
           urc.target_id,
           u.name as target_name,
           urc.rank_position,
           urc.affinity_score,
           COALESCE(photo_counts.unlocked_count, 0) as photos_unlocked,
           (urc.affinity_score >= $1) as can_meet
         FROM user_ranking_cache urc
         JOIN users u ON urc.target_id = u.id
         LEFT JOIN (
           SELECT
             up.user_id,
             COUNT(*) as unlocked_count
           FROM user_photos up
           JOIN photo_mask_states pms ON up.id = pms.photo_id
           WHERE pms.user_id = $2 AND pms.visible_stage != 'LOCKED'
           GROUP BY up.user_id
         ) photo_counts ON urc.target_id = photo_counts.user_id
         WHERE urc.user_id = $2
         ORDER BY urc.rank_position
         LIMIT $3`,
        [config.AFFINITY_T3_THRESHOLD, userId, config.RANKING_TOP_COUNT]
      );
    } catch (dbError) {
      // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïò§Î•ò Ïãú ÏïàÏ†ÑÌïú ÎåÄÏ≤¥ ÏùëÎãµ
      console.error('üö® [AffinityService] Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï°∞Ìöå Ïò§Î•ò:', dbError);
      console.log('üîÑ [AffinityService] ÏïàÏ†ÑÌïú Îπà ÏùëÎãµÏúºÎ°ú ÎåÄÏ≤¥');

      return {
        rankings: [],
        userPosition: undefined
      };
    }

    console.log('üìä [AffinityService] Îû≠ÌÇπ Ï°∞Ìöå Í≤∞Í≥º:', {
      userId,
      rankingCount: rankings.length,
      T3_THRESHOLD: config.AFFINITY_T3_THRESHOLD,
      TOP_COUNT: config.RANKING_TOP_COUNT
    });

    if (rankings.length > 0) {
      console.log('üèÜ [AffinityService] ÏÉÅÏúÑ Îû≠ÌÇπ:', rankings.slice(0, 3).map(r => ({
        rank: r.rank_position,
        target: r.target_name,
        score: r.affinity_score,
        canMeet: r.can_meet
      })));
    } else {
      console.warn('‚ö†Ô∏è [AffinityService] Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùå');
    }

    const result = {
      rankings: rankings.map(r => ({
        targetId: r.target_id,
        targetName: r.target_name,
        rankPosition: r.rank_position,
        affinityScore: r.affinity_score,
        photosUnlocked: r.photos_unlocked,
        canMeet: r.can_meet
      })),
      userPosition: undefined // Could implement user's own ranking position
    };

    console.log('üéâ [AffinityService] getUserRanking ÏôÑÎ£å:', {
      returnedRankings: result.rankings.length
    });

    // üõ°Ô∏è ÏÑúÎ≤Ñ Î©îÎ™®Î¶¨ Ï∫êÏãúÏóê ÏïàÏ†ÑÌïòÍ≤å Ï†ÄÏû• (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
    try {
      if (this.rankingCache && this.rankingCache instanceof Map) {
        const cacheKey = `ranking_${userId}`;

        // Ï∫êÏãúÏóê Í≤∞Í≥º Ï†ÄÏû•
        this.rankingCache.set(cacheKey, {
          data: result,
          timestamp: Date.now()
        });

        // Ï∫êÏãú ÌÅ¨Í∏∞ Ï†úÌïú (ÏµúÎåÄ 100Í∞ú ÏÇ¨Ïö©Ïûê)
        if (this.rankingCache.size > 100) {
          try {
            const oldestKey = this.rankingCache.keys().next().value;
            if (oldestKey) {
              this.rankingCache.delete(oldestKey);
            }
          } catch (cleanupError) {
            console.warn('‚ö†Ô∏è [AffinityService] Ï∫êÏãú Ï†ïÎ¶¨ Ïò§Î•ò:', cleanupError);
            // Ï†ïÎ¶¨ Ïã§Ìå®Ïãú Ï∫êÏãú Ï†ÑÏ≤¥ Ïû¨ÏÑ§Ï†ï
            this.rankingCache = new Map();
            this.rankingCache.set(cacheKey, {
              data: result,
              timestamp: Date.now()
            });
          }
        }

        console.log('üíæ [AffinityService] ÏÑúÎ≤Ñ Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å');
      } else {
        console.warn('‚ö†Ô∏è [AffinityService] Ï∫êÏãú ÏãúÏä§ÌÖú ÎπÑÌôúÏÑ±ÌôîÎê® - Ï†ÄÏû• Í±¥ÎÑàÎúÄ');
      }
    } catch (saveError) {
      // Ï∫êÏãú Ï†ÄÏû• Ïã§Ìå®Ìï¥ÎèÑ ÏùëÎãµÏùÄ Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Î∞òÌôò
      console.error('üö® [AffinityService] Ï∫êÏãú Ï†ÄÏû• Ïò§Î•ò:', saveError);
      console.log('‚úÖ [AffinityService] Ï∫êÏãú Ï†ÄÏû• Ïã§Ìå®ÌñàÏßÄÎßå ÏùëÎãµÏùÄ Ï†ïÏÉÅ Î∞òÌôò');
    }

    return result;
  }

  /**
   * Update ranking cache for user
   */
  async updateRankingCache(userId: string): Promise<void> {
    try {
      await this.db.transaction(async (client) => {
        try {
          // üõ°Ô∏è ÏÇ¨Ïö©Ïûê ÏπúÌôîÎèÑ Îç∞Ïù¥ÌÑ∞ ÏïàÏ†ÑÌïòÍ≤å Ï°∞Ìöå
          const affinities = await client.query(
            `SELECT target_id, score
             FROM affinity
             WHERE viewer_id = $1
             ORDER BY score DESC`,
            [userId]
          );

          console.log(`üìä [AffinityService] ${userId} ÏÇ¨Ïö©ÏûêÏùò ÏπúÌôîÎèÑ Îç∞Ïù¥ÌÑ∞ ${affinities.length}Í∞ú Ï°∞ÌöåÎê®`);

          // üõ°Ô∏è Í∏∞Ï°¥ Ï∫êÏãú ÏïàÏ†ÑÌïòÍ≤å ÏÇ≠Ï†ú
          try {
            await client.query(
              'DELETE FROM user_ranking_cache WHERE user_id = $1',
              [userId]
            );
            console.log(`üóëÔ∏è [AffinityService] ${userId} ÏÇ¨Ïö©ÏûêÏùò Í∏∞Ï°¥ Ï∫êÏãú ÏÇ≠Ï†ú ÏôÑÎ£å`);
          } catch (deleteError) {
            console.warn('‚ö†Ô∏è [AffinityService] Í∏∞Ï°¥ Ï∫êÏãú ÏÇ≠Ï†ú Ïã§Ìå® (Î¨¥ÏãúÎê®):', deleteError);
          }

          // üõ°Ô∏è ÏÉàÎ°úÏö¥ Îû≠ÌÇπ ÏïàÏ†ÑÌïòÍ≤å ÏÇΩÏûÖ
          let insertCount = 0;
          for (let i = 0; i < affinities.length; i++) {
            try {
              await client.query(
                `INSERT INTO user_ranking_cache (user_id, target_id, rank_position, affinity_score, updated_at)
                 VALUES ($1, $2, $3, $4, NOW())`,
                [userId, affinities[i].target_id, i + 1, affinities[i].score]
              );
              insertCount++;
            } catch (insertError) {
              console.warn(`‚ö†Ô∏è [AffinityService] Îû≠ÌÇπ ${i + 1} ÏÇΩÏûÖ Ïã§Ìå®:`, insertError);
              // Í∞úÎ≥Ñ ÏÇΩÏûÖ Ïã§Ìå®Îäî Ï†ÑÏ≤¥ ÏûëÏóÖÏùÑ Ï§ëÎã®ÌïòÏßÄ ÏïäÏùå
            }
          }

          console.log(`‚úÖ [AffinityService] ${userId} ÏÇ¨Ïö©Ïûê Îû≠ÌÇπ Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å: ${insertCount}/${affinities.length}`);

        } catch (transactionError) {
          console.error('üö® [AffinityService] Ìä∏ÎûúÏû≠ÏÖò ÎÇ¥Î∂Ä Ïò§Î•ò:', transactionError);
          throw transactionError; // Ìä∏ÎûúÏû≠ÏÖò Î°§Î∞±ÏùÑ ÏúÑÌï¥ Îã§Ïãú throw
        }
      });
    } catch (error) {
      console.error('üí• [AffinityService] updateRankingCache Ï†ÑÏ≤¥ Ïã§Ìå®:', error);
      throw new Error(`Îû≠ÌÇπ Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: ${error.message}`);
    }
  }
}

export const pointsService = new PointsService();
export const affinityService = new AffinityService();